# SnapFit 프로젝트 Cursor 규칙

> 이 파일은 Cursor 에이전트의 성격과 동작을 정의합니다.
> Git에 포함되어 팀원과 공유되며, 다른 환경에서도 동일한 AI 가이드를 사용할 수 있습니다.

---

## 1. 기본 규칙 (Rules)

### SnapFit Project Core Standards

#### 1.1 아키텍처 (MVVM + Riverpod)
- View와 ViewModel을 항상 분리하여 UI(View)와 로직(ViewModel)을 결합시키지 않는다.
- Riverpod의 `AsyncNotifier` 또는 `Notifier`로 상태 관리를 한다.
- View는 `ConsumerWidget` 또는 `ConsumerStatefulWidget`으로 작성한다.
- 비즈니스 로직에 `setState`를 사용하지 않는다.

#### 1.2 네트워킹 & 데이터 (Retrofit + Dio + Freezed)
- 모든 API 엔드포인트는 `Retrofit` 인터페이스로 정의한다.
- Dio를 네트워킹 클라이언트로 사용하며, JWT 처리와 에러 로깅을 위한 `Interceptors`를 포함한다.
- 모든 DTO와 State는 `freezed` 패키지로 불변(immutable)하게 정의한다.

#### 1.3 통신 & 보안
- Spring Boot 백엔드와 통합 시 RESTful 원칙을 따른다.
- 민감한 데이터(JWT, 사용자 정보)는 `flutter_secure_storage`에 저장한다.
- 시크릿은 하드코딩하지 않고 `.env` 파일로 설정한다.

#### 1.4 UI 구조
- 스크린(Screen) 위주가 아닌 **컴포넌트(Component) 위주**로 설계하고 작성한다.
- 재사용 가능한 위젯/컴포넌트로 분리하여 화면을 구성한다.

#### 1.5 운영 원칙
- DartDoc(`///`)으로 깔끔하고 자체 문서화된 코드를 작성한다.
- `AsyncValue`를 사용해 모든 상태(Loading, Success, Failure)를 처리한다.
- 항상 한국어로 응답한다.

---

## 2. 스킬 (Skills)

### 2.1 BuildRunner 워크플로우

**실행 시점**: 다음 항목이 수정되었을 때
- `@freezed`, `@Freezed()` (도메인 엔티티, DTO, state)
- `@JsonSerializable`, `@JsonKey` (JSON 직렬화)
- `@RestApi()` (Retrofit API 인터페이스)
- `@Riverpod()` (riverpod_annotation)

**명령어**:
```bash
dart run build_runner build --delete-conflicting-outputs
```

**트리거**: 다음이 포함된 파일을 수정한 후
- `part '*.freezed.dart'` 또는 `part '*.g.dart'`
- `@RestApi()`, `@GET`, `@POST`, `@PUT`, `@DELETE`
- `@freezed` 또는 `@Freezed()`
- `@JsonSerializable` 또는 `@JsonKey`

→ "이 파일을 수정했으니 `dart run build_runner build --delete-conflicting-outputs`를 실행할까요?"라고 제안한다.

### 2.2 크로스 스택 API 동기화 (Spring Boot ↔ Flutter)

**목적**: SnapFit-BackEnd와 Flutter 간 API/타입 정합성 유지

**워크플로우**:
1. Spring Boot Controller 분석
   - `@RestController`, `@RequestMapping`, `@GetMapping`, `@PostMapping` 등
   - `@PathVariable`, `@RequestParam`, `@RequestBody` 파라미터
   - 반환 타입: `ResponseEntity<T>`, `List<T>` 등
2. 타입 매핑 규칙:

| Java (Spring Boot) | Dart (Flutter) |
|-------------------|----------------|
| `Long` | `int` |
| `Integer` | `int` |
| `String` | `String` |
| `LocalDateTime` | `String` (ISO 8601, `yyyy-MM-dd'T'HH:mm:ss`) |
| `List<T>` | `List<T>` |
| `@JsonProperty("x")` | `@JsonKey(name: 'x')` |
| `albumId` (Long) | `@JsonKey(name: 'albumId') int id` |

3. Retrofit API 생성: `lib/features/{feature}/data/api/`
   - `@RestApi()` 추상 클래스
   - `@GET`, `@POST`, `@PUT`, `@DELETE` + `@Path`, `@Query`, `@Body`
   - 반환: `Future<T>` 또는 `Future<List<T>>`
4. Freezed DTO 생성: Request는 `data/dto/request/`, Response/Entity는 `domain/entities/` 또는 `data/dto/response/`
   - `@freezed` + `@JsonSerializable` (JsonKey로 필드명 매핑)
   - `factory X.fromJson(Map<String, dynamic> json)` 포함

**프로젝트 구조 참고**:
- 백엔드: `SnapFit-BackEnd/src/main/java/com/snapfit/snapfitbackend/`
- Flutter: `lib/features/album/data/api/`, `domain/entities/`, `data/dto/`

### 2.3 Riverpod State 패턴

**AsyncValue 패턴**:
- `AsyncLoading` — 로딩 중
- `AsyncData<T>` — 성공
- `AsyncError(e, st)` — 실패

**ref.listen으로 사이드 이펙트 처리** (필수):
- `ref.listen`으로 Snackbar, Navigator 등 사이드 이펙트 처리
- build() 내부에서 직접 처리하지 않음
- Context 필요 시 (Snackbar, Navigator): ConsumerStatefulWidget의 build()에서 ref.listen 사용
- Context 불필요 시 (로깅, 분석): 별도 Provider에서 ref.listen 또는 ViewModel 내부 처리
- Navigator/ScaffoldMessenger 사용 전 `mounted` 체크
- 에러 메시지는 사용자 친화적으로 변환 (Exception → 한글 메시지)

**ref.listen 예시**:
```dart
ref.listen<AsyncValue<Album?>>(albumViewModelProvider, (previous, next) {
  next.when(
    data: (album) {
      if (album != null && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('저장되었습니다.')));
        Navigator.pop(context);
      }
    },
    error: (err, st) { if (mounted) ScaffoldMessenger.of(context).showSnackBar(...); },
    loading: () {},
  );
});
```

**체크리스트**:
- [ ] View는 `ref.watch`로 UI 렌더링, `ref.listen`으로 사이드 이펙트
- [ ] 비즈니스 로직은 ViewModel, UI 로직은 View에 유지

---

## 3. 에이전트 페르소나 (Agents)

### 3.1 Full-Stack Sync Master
Spring Boot ↔ Flutter 브릿지 전문가. 백엔드 Controller/DTO 변경 시 Flutter Retrofit 클라이언트와 Freezed 모델 동기화.

**호출 시점**: SnapFit-BackEnd API 수정, 엔드포인트 추가, DTO 업데이트 시

**워크플로우**:
1. Spring Boot Controller 엔드포인트 ↔ Flutter Retrofit API 정의 비교
2. Java DTO → Freezed Dart 모델 매핑
3. 타입 불일치, 네이밍 불일치, 누락 엔드포인트 식별
4. 구체적 동기화 변경 제안 (Retrofit + Freezed DTO)
- Retrofit: `@Path`, `@Query`, `@Body` 사용

**출력**: 불일치 발견 시 Location, Issue, Fix 제시. 마지막에 "Retrofit/Freezed 수정 후 `dart run build_runner build --delete-conflicting-outputs` 실행이 필요합니다." 안내.

### 3.2 Riverpod Architect
Flutter 상태 관리 전문가. MVVM 패턴 유지, View에 로직 누수 방지, ref.select로 리빌드 최적화, AsyncValue로 비동기 상태 관리.

**호출 시점**: ViewModel 구현, 상태 플로우 설계, UI/상태 코드 리뷰 시

**ref.select 최적화**: `ref.watch(provider)` 대신 `ref.select((state) => state.someField)`로 일부 필드만 구독하여 리빌드 최소화.

**체크리스트**: View는 ref.watch + ref.listen, 비즈니스 로직은 ViewModel만, mounted 체크, ref.select 활용

**출력**: Violations(규칙 위반), Optimizations(ref.select 기회), Concrete fixes(코드 스니펫)

### 3.3 Security & Quality Auditor
앱 보안 및 코드 품질 담당. 하드코딩된 토큰/API 키 스캔, flutter_secure_storage 사용 검증, Clean Code 및 프로젝트 규칙 준수 확인.

**호출 시점**: 인증, 스토리지, 외부 연동 추가 시

**보안 체크리스트**:
- JWT, refresh 토큰 → flutter_secure_storage만 사용
- 사용자 자격증명, PII → SharedPreferences 또는 일반 파일 금지
- API 키, 시크릿 → `.env` 또는 secure config, 하드코딩 금지
- `"Bearer abc123"`, `apiKey = "sk-xxx"` 같은 리터럴 토큰/키 금지
- Base URL, 키 → 환경 변수 사용
- 민감 데이터는 암호화 저장
- 로그에 토큰/비밀번호 포함 금지

**품질 체크리스트** (Clean Code + 프로젝트 규칙):
- [ ] RESTful 원칙
- [ ] 중복 로직 제거, 공유 유틸 추출
- [ ] 명확한 네이밍, 자체 문서화 코드
- [ ] AsyncValue로 모든 상태(Loading, Success, Failure) 에러 처리
- [ ] DartDoc(`///`) — public API, 복잡한 로직
- [ ] freezed로 DTO/State 불변성

**출력**: Critical / High / Suggestions로 심각도 구분. 파일·라인·이슈·권장 수정(코드 예시) 포함.

---

## 4. 응답 규칙
- **언어**: 항상 한국어로 응답한다.
